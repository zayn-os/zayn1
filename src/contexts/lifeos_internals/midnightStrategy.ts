
import { UserProfile, DailyMode, Toast } from '../../types/types';
import { DAILY_TARGETS, MILESTONE_REWARDS } from '../../types/constants';
import { sendNotification } from '../../utils/notifications';
import { calculateMonthlyAverage, generateMonthBadge } from '../../utils/honorSystem';
import { BadgeDefinition } from '../../types/badgeTypes';

interface MidnightResult {
    newUser: UserProfile;
    toastMessage: string;
    toastType: Toast['type'];
    newBadge?: BadgeDefinition; // ðŸ‘ˆ Badge generated by system
}

export const calculateMidnightUpdates = (user: UserProfile, debugDate: string | null | undefined): MidnightResult => {
    const target = user.dailyTarget;
    const earned = user.dailyXP;
    const targetMet = earned >= target; // Did they hit the daily goal?
    
    // Use debug date if available, otherwise real time
    const now = debugDate ? new Date(debugDate) : new Date();
    
    // ðŸ—“ï¸ 1. HONOR LOGIC (Log Yesterday's Score)
    // We modify the score for the day that effectively just ended.
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayIso = yesterday.toISOString().split('T')[0];

    // Ensure Daily Log exists
    const dailyLog = { ...(user.honorDailyLog || {}) };
    
    // Base Score: Starts at 100, reduced by penalties during the day.
    let dailyScore = dailyLog[yesterdayIso] !== undefined ? dailyLog[yesterdayIso] : 100;

    // ðŸŒŸ THE 110% BONUS LOGIC
    // If user hit the XP Target, they earn a +10% Buffer Bonus.
    // This allows recovery from previous mistakes (10 days to fix 1 lost day).
    if (targetMet) {
        dailyScore += 10;
    }

    // Clamp the score: Min 0, Max 110 (The new ceiling)
    dailyScore = Math.min(110, Math.max(0, dailyScore));
    
    // Save to Log
    dailyLog[yesterdayIso] = dailyScore;

    // ðŸ—“ï¸ 2. CHECK FOR MONTH CHANGE (HARVEST TIME)
    let newBadge: BadgeDefinition | undefined = undefined;
    let badgeToast = "";
    
    // If today is the 1st of a new month, process the PREVIOUS month
    if (now.getDate() === 1) {
        // Calculate average for the COMPLETED month
        const prevMonthDate = new Date(now);
        prevMonthDate.setMonth(prevMonthDate.getMonth() - 1);
        const prevMonthName = prevMonthDate.toLocaleString('default', { month: 'long' });
        const prevMonthYear = prevMonthDate.getFullYear();
        const prevMonthPrefix = prevMonthDate.toISOString().slice(0, 7);

        const monthScores = Object.entries(dailyLog)
            .filter(([d]) => d.startsWith(prevMonthPrefix))
            .map(([, s]) => s);
        
        // If we have data, generate badge
        if (monthScores.length > 0) {
            const sum = monthScores.reduce((a, b) => a + b, 0);
            // Average can technically be > 100 now (e.g. 102%), but we cap it at 100 for the badge display logic usually.
            // However, allowing >100 is cool for "Overachiever" status.
            // Let's pass the raw average. The badge generator handles >= 99 as Crimson.
            const finalAverage = Math.round(sum / monthScores.length);
            
            newBadge = generateMonthBadge(finalAverage, prevMonthName, prevMonthYear);
            badgeToast = ` | ðŸŽ–ï¸ ${prevMonthName} Rank: ${finalAverage}%`;
        }
    }

    // Recalculate Current Rolling Honor (Average for NEW/CURRENT month)
    const newAverageHonor = calculateMonthlyAverage(dailyLog, now.toISOString());

    // ----------------------------------------------------------------
    // âš”ï¸ STANDARD STREAK LOGIC (Existing)
    // ----------------------------------------------------------------
    
    let newStreak = user.streak;
    let newGold = user.gold;
    let newShields = user.shields;
    let newConsecutiveShields = user.consecutiveShields || 0;
    let newShieldsUsedMetric = user.metrics.shieldsUsed;
    let toastMessage = '';
    let toastType: Toast['type'] = 'info';
    
    if (targetMet) {
        newStreak++;
        newConsecutiveShields = 0; 
        
        const salary = user.currentMode === DailyMode.HARD ? 200 : user.currentMode === DailyMode.NORMAL ? 100 : 50;
        newGold += salary;
        
        // ðŸŒŸ CUSTOM MESSAGE FOR OVERCHARGED HONOR
        if (dailyScore > 100) {
            toastMessage = `âš”ï¸ Flawless Victory! Honor Overcharged (${dailyScore}%) | +${salary}G`;
            toastType = 'crit'; // Special visual effect
        } else {
            toastMessage = `ðŸŒ… New Day! Streak ${newStreak} | +${salary}G | Honor +10%`;
            toastType = 'success';
        }

        const bonus = MILESTONE_REWARDS[newStreak];
        if (bonus) {
            newGold += bonus;
            toastMessage = `ðŸ… Milestone: ${newStreak} Days! +${bonus}G`;
            toastType = 'level-up';
            if (user.preferences.deviceNotificationsEnabled) {
                sendNotification('ðŸ… Milestone Reached!', `You hit a ${newStreak} day streak! Bonus ${bonus}G awarded.`);
            }
        } else if (user.preferences.deviceNotificationsEnabled) {
            sendNotification('ðŸŒ… Protocol Reset', `New day initiated. Streak: ${newStreak}. Honor: ${dailyScore}%.`);
        }
    } 
    else {
        const hasShield = newShields > 0;
        const canUseShield = newConsecutiveShields < 3; 

        if (hasShield && canUseShield) {
            newShields--;
            newConsecutiveShields++;
            newShieldsUsedMetric++;
            toastMessage = `ðŸ›¡ï¸ Streak Saved by Shield (${newShields} Remaining)`;
            toastType = 'info';
            if (user.preferences.deviceNotificationsEnabled) {
                sendNotification('ðŸ›¡ï¸ Shield Deployed', `Your streak was saved. ${newShields} shields remaining.`);
            }
        } else {
            if (hasShield && !canUseShield) {
                toastMessage = `ðŸ›¡ï¸ Shield Limit Exceeded! Streak Shattered.`;
            } else {
                toastMessage = `â˜ ï¸ Target Missed. Streak Lost.`;
            }
            newStreak = 0;
            newConsecutiveShields = 0;
            toastType = 'error';
            if (user.preferences.deviceNotificationsEnabled) {
                sendNotification('â˜ ï¸ Streak Lost', 'Protocol failed. System reset to Day 0.');
            }
        }
    }

    if (badgeToast) {
        toastMessage += badgeToast;
        toastType = 'level-up';
    }

    const nextMode = user.pendingMode;
    const nextTarget = DAILY_TARGETS[nextMode];

    const newUser: UserProfile = {
        ...user,
        streak: newStreak,
        gold: newGold,
        shields: newShields,
        honor: newAverageHonor, // ðŸ‘ˆ Updated Rolling Average
        honorDailyLog: dailyLog, // ðŸ‘ˆ Updated Log with the +5% logic
        consecutiveShields: newConsecutiveShields,
        dailyXP: 0, 
        dailyTarget: nextTarget, 
        currentMode: nextMode, 
        lastProcessedDate: now.toISOString(),
        lastOnline: now.toISOString(),
        metrics: {
            ...user.metrics,
            shieldsUsed: newShieldsUsedMetric,
            highestStreak: Math.max(user.metrics.highestStreak, newStreak)
        }
    };

    return { newUser, toastMessage, toastType, newBadge };
};
